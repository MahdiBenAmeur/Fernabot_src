from fastapi import FastAPI, Request
from fastapi.responses import PlainTextResponse
import requests

import config
import db
#from nlpmodul import get_intent
from config import  VERIFICATION_TOKEN, moreOptionsPressedIndicator

app = FastAPI()

# Conversation tree structure
# Each node represents a step in the conversation.
# "options" contains references to other nodes (identified by keys like "2", "3", etc.)
# "action" can be a function that fetches data or returns dynamic content.
tree = {
    # Main Menu
    "1": {
        "message": "ุฃููุง ูุณููุง ุจูู ูู ูุฑูุง ุจูุช ๐ค! ูุงูู ููุง ุจุงุด ูุนุงููู ุชููู ูุฑุต ุชุฏุฑูุจ ๐ ูุฎุฏูุฉ ูู ูุฑูุงูุฉ. ููุฏุฑ ูุนุทูู ุขุฎุฑ ุงูุฃุฎุจุงุฑ ุนูู ุงูุชุฏุฑูุจุงุช ูุงููุฑุต ุงูููููุฉ. ุฅุฎุชุงุฑ ุดููุง ุชุญุจ ุชุนุฑู ุฃูุซุฑ ๐ค ูุฃูุง ูู ุงูุฎุฏูุฉ! ๐",
        "title": "ุงููุงุฆูุฉ ุงูุฑูููุณูุฉ",
        "options": ["2", "3", "4", "6"],
        "action": ""
    },

    # Job Opportunities
    "2": {
        "message": "ุชุญุจ ุชุนุฑู ุนูู ูุฑุต ุงูุฎุฏูุฉุ ุงุฎุชุงุฑ ูุงุญุฏ ูู ูุงููุทุงุนุงุช:",
        "title": "ูุฑุต ุงูุฎุฏูุฉ",
        "options": ["2,1", "2,2", "2,3", "2,4"],
        "action": ""
    },
    "2,1": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุนูู ูู **ุงููุทุงุน ุงูุชููุณู**:",
        "title": "ุชููุณูุฉ",
        "options": ["2,1,1","1"],
        "action": lambda: db.get_emploi_by_genre("ุชููุณูุฉ")
    },
    "2,2": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุนูู ูู **ุงููุทุงุน ุงูุฏููู**:",
        "title": "ุฏูููุฉ",
        "options": ["2,1,1","1"],
        "action": lambda: db.get_emploi_by_genre("ุฏูููุฉ")
    },
    "2,3": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุนูู ูู **ุงููุทุงุน ุงูุฎููุฌู**:",
        "title": "ุฎููุฌูุฉ",
        "options": ["2,1,1","1"],
        "action": lambda: db.get_emploi_by_genre("ุฎููุฌูุฉ")
    },
    "2,4": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุนูู ูู **ุชูููู ูููู**:",
        "title": "ุชูููู ูููู",
        "options": ["2,1,1","1"],
        "action": lambda: db.get_emploi_by_genre("ุชูููู ูููู")
    },

    # Training Opportunities
    "3": {
        "message": "ุชุญุจ ุชุนุฑู ุนูู ุงูุฏูุฑุงุช ุงูุชุฏุฑูุจูุฉ ุงููุชุงุญุฉุ ุงุฎุชุงุฑ ูู ุงููุฌุงูุงุช ุงูุชุงููุฉ:",
        "title": "ุฏูุฑุงุช ุชุฏุฑูุจูุฉ",
        "options": ["3,1", "3,2", "3,3", "3,4", "3,5", "3,6", "3,7", "3,8"],
        "action": ""
    },
    "3,1": {
        "message": "ุฃุญุฏุซ ุฏูุฑุงุช ูู ูุฌุงู **ุงูุชูููููุฌูุง**:",
        "title": "ุงูุชูููููุฌูุง",
        "options": ["3,1,1","1"],
        "action": lambda: db.get_courses_by_genre("ุงูุชูููููุฌูุง")
    },
    "3,2": {
        "message": "ุฃุญุฏุซ ุฏูุฑุงุช ูู ูุฌุงู **ุงูุฃุนูุงู**:",
        "title": "ุงูุฃุนูุงู",
        "options": ["3,1,1","1"],
        "action": lambda: db.get_courses_by_genre("ุงูุฃุนูุงู")
    },
    "3,3": {
        "message": "ุฃุญุฏุซ ุฏูุฑุงุช ูู ูุฌุงู **ุนููู ุงูุจูุงูุงุช**:",
        "title": "ุนููู ุงูุจูุงูุงุช",
        "options": ["3,1,1","1"],
        "action": lambda: db.get_courses_by_genre("ุนููู ุงูุจูุงูุงุช")
    },
    "3,4": {
        "message": "ุฃุญุฏุซ ุฏูุฑุงุช ูู ูุฌุงู **ุงูุตุญุฉ**:",
        "title": "ุงูุตุญุฉ",
        "options": ["3,1,1","1"],
        "action": lambda: db.get_courses_by_genre("ุงูุตุญุฉ")
    },
    "3,5": {
        "message": "ุฃุญุฏุซ ุฏูุฑุงุช ูู ูุฌุงู **ุงูุนููู ุงูุงุฌุชูุงุนูุฉ**:",
        "title": "ุงูุนููู ุงูุงุฌุชูุงุนูุฉ",
        "options": ["3,1,1","1"],
        "action": lambda: db.get_courses_by_genre("ุงูุนููู ุงูุงุฌุชูุงุนูุฉ")
    },
    "3,6": {
        "message": "ุฃุญุฏุซ ุฏูุฑุงุช ูู ูุฌุงู **ุงูุชูููุฉ ุงููุณุชุฏุงูุฉ**:",
        "title": "ุงูุชูููุฉ ุงููุณุชุฏุงูุฉ",
        "options": ["3,1,1","1"],
        "action": lambda: db.get_courses_by_genre("ุงูุชูููุฉ ุงููุณุชุฏุงูุฉ")
    },
    "3,7": {
        "message": "ุฃุญุฏุซ ุฏูุฑุงุช ูู ูุฌุงู **ุญููู ุงูุฅูุณุงู**:",
        "title": "ุญููู ุงูุฅูุณุงู",
        "options": ["3,1,1","1"],
        "action": lambda: db.get_courses_by_genre("ุญููู ุงูุฅูุณุงู")
    },
    "3,8": {
        "message": "ุฃุญุฏุซ ุฏูุฑุงุช ูู ูุฌุงู **ุงููููู ูุงูุชุนููู**:",
        "title": "ุงููููู ูุงูุชุนููู",
        "options": ["3,1,1","1"],
        "action": lambda: db.get_courses_by_genre("ุงููููู ูุงูุชุนููู")
    },

    # Project Support
    "4": {
        "message": "ุนูุฏู ูุดุฑูุน ุฃู ููุฑุฉ ูุดุฑูุน ุฌุฏูุฏุฉ ู ุชุญุจ ุชููู ุฏุนู ุฃู ุชููููุ ูุฌูู ูุนุงูููู ูู ูุฐุง.",
        "title": "ุจุนุซ ูุดุฑูุน",
        "options": ["4,1", "5", "1"],
        "action": ""
    },
    "4,1": {
        "message": "ุจุงุด ุชุชุนุฑู ุนูู ูุฑุต ุงูุฏุนู ุงููุชููุฑู ุ ุฅุฎุชุงุฑ ููุน ุงูุฏุนู ุงูู ุญุงุดุชู ุจูู:",
        "title": "ุฏุนู ุฅุฏุงุฑู ููุคุณุณุงุชูุ",
        "options": ["4,1,1", "4,1,2", "4,1,3", "4,1,4", "4,1,5", "1"],
        "action": ""
    },
    "4,1,1": {
        "message": "ุฃุญุฏุซ ุงููุฑุต ุงููุชุงุญุฉ ููููุญ ุงูุฏุฑุงุณูุฉ:",
        "title": "ููุญ ุฏุฑุงุณูุฉ",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_support_opportunities_by_type("ููุญ ุฏุฑุงุณูุฉ")
    },
    "4,1,2": {
        "message": "ุฃุญุฏุซ ุงููุฑุต ุงููุชุงุญุฉ ููุฒูุงูุงุช:",
        "title": "ุฒูุงูุงุช",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_support_opportunities_by_type("ุฒูุงูุงุช")
    },
    "4,1,3": {
        "message": "ุฃุญุฏุซ ุงููุฑุต ุงููุชุงุญุฉ ูุจุฑุงูุฌ ุงูุชุจุงุฏู:",
        "title": "ุจุฑุงูุฌ ุงูุชุจุงุฏู",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_support_opportunities_by_type("ุจุฑุงูุฌ ุงูุชุจุงุฏู")
    },
    "4,1,4": {
        "message": "ุฃุญุฏุซ ุงููุฑุต ุงููุชุงุญุฉ ูุจุฑุงูุฌ ุงูุชุทูุน:",
        "title": "ุจุฑุงูุฌ ุงูุชุทูุน",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_support_opportunities_by_type("ุจุฑุงูุฌ ุงูุชุทูุน")
    },
    "4,1,5": {
        "message": "ุงูุชุดู ูุฑุต ุชุนูู ูุบุงุช ุฌุฏูุฏุฉ:",
        "title": "ุชุนูู ูุบุฉ ุฌุฏูุฏุฉ",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_support_opportunities_by_type("ุชุนูู ูุบุฉ ุฌุฏูุฏุฉ")
    },

    "5": {
        "message": "ุชููุฌ ุนูู ุทุฑููุฉ ุจุงุด ุชููู ุงููุดุฑูุน ุชุงุนูุ ุงุฎุชุงุฑ ููุน ุงูุฏุนู ุงูู ุญุงุดุชู ุจูู:",
        "title": "ุจุญุซ ุนู ุชููููุ",
        "options": ["5,1", "5,2", "5,3", "5,4", "5,5", "5,6", "5,7", "5,8", "5,9"],
        "action": ""
    },
    "5,1": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุฑูุงุฏุฉ ุงูุฃุนูุงู**",
        "title": "ุฑูุงุฏุฉ ุงูุฃุนูุงู",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุฑูุงุฏุฉ ุงูุฃุนูุงู")
    },
    "5,2": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุงูุชูููู**",
        "title": "ุงูุชูููู",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุงูุชูููู")
    },
    "5,3": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุฅุฏุงุฑุฉ ุงููุดุงุฑูุน**",
        "title": "ุฅุฏุงุฑุฉ ุงููุดุงุฑูุน",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุฅุฏุงุฑุฉ ุงููุดุงุฑูุน")
    },
    "5,4": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุงูุงุจุชูุงุฑ**",
        "title": "ุงูุงุจุชูุงุฑ",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุงูุงุจุชูุงุฑ")
    },
    "5,5": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุงูููุงุญุฉ**",
        "title": "ุงูููุงุญุฉ",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุงูููุงุญุฉ")
    },
    "5,6": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุงูุชูููุฉ ุงููุณุชุฏุงูุฉ**",
        "title": "ุงูุชูููุฉ ุงููุณุชุฏุงูุฉ",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุงูุชูููุฉ ุงููุณุชุฏุงูุฉ")
    },
    "5,7": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุงูุตูุงุนุฉ**",
        "title": "ุงูุตูุงุนุฉ",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุงูุตูุงุนุฉ")
    },
    "5,8": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุงูุชูููุฉ ุงููุญููุฉ**",
        "title": "ุงูุชูููุฉ ุงููุญููุฉ",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุงูุชูููุฉ ุงููุญููุฉ")
    },
    "5,9": {
        "message": "ุฃุญุฏุซ ูุฑุต ุงูุฏุนู ููุดุงุฑูุน **ุงูุชุนููู ูุงูุชุฏุฑูุจ ุงููููู**",
        "title": "ุงูุชุนููู ูุงูุชุฏุฑูุจ ุงููููู",
        "options": ["4,1,1,1","1"],
        "action": lambda: db.get_financing_opportunities("ุงูุชุนููู ูุงูุชุฏุฑูุจ ุงููููู")
    },

    # Help and Support
    "6": {
        "message": "ูููุณุงุนุฏุฉ ุฃู ุงูุฅุณุชูุณุงุฑุงุช ุงุชุตู ุจููุง. :12 345 678",
        "title": "ูุณุงุนุฏุฉ",
        "options": ["1"],
        "action": ""
    },

    # Additional Pagination Nodes
    "2,1,1": {
        "message": "..",
        "title": "ุฒูุฏูู",
        "options": ["1", "2,1,1"],
        "action": ""
    },
    "3,1,1": {
        "message": "..",
        "title": "ุฒูุฏูู",
        "options": ["1", "3,1,1"],
        "action": ""
    },
    "4,1,1,1": {
        "message": "..",
        "title": "ุฒูุฏูู",
        "options": ["1", "4,1,1,1"],
        "action": ""
    }
}


@app.get("/webhook")
async def verify(request: Request):
    """
    Endpoint to verify Facebook webhook setup.
    """
    mode = request.query_params.get('hub.mode')
    token = request.query_params.get('hub.verify_token')
    challenge = request.query_params.get('hub.challenge')

    if mode == 'subscribe' and token == VERIFICATION_TOKEN:
        return PlainTextResponse(challenge)
    else:
        return PlainTextResponse("Verification failed", status_code=403)


def send_message(recipient_id: str, message: dict) -> dict:
    """
    Send a message using Facebook's Send API.
    """
    url = f"https://graph.facebook.com/v11.0/me/messages?access_token={config.BOT_TOKEN}"
    headers = {"Content-Type": "application/json"}
    payload = {
        "recipient": {"id": recipient_id},
        "message": message
    }
    response = requests.post(url, json=payload, headers=headers)
    return response.json()


def build_quick_replies(options: list, trigger: str, start: int) -> list:
    """
    Build quick reply buttons based on the given options.
    Each option corresponds to a node in the conversation tree.
    """
    quick_replies = []
    for option in options:
        if option in tree:
            node = tree[option]
            title = node.get('title', node['message'])
            if title == "ุฒูุฏูู":
                # "ุฒูุฏูู" indicates loading more options (pagination).
                next_payload = f"{moreOptionsPressedIndicator}_{trigger[0]}_{tree[trigger]['title']}_{start}"
                print("next_payload", next_payload)
                quick_replies.append({
                    "content_type": "text",
                    "title": title,
                    "payload": next_payload
                })
            else:
                quick_replies.append({
                    "content_type": "text",
                    "title": title,
                    "payload": option
                })
    return quick_replies


def build_more_option_response(payload: str) -> dict:
    """
    Build a response when the user requests more options (pagination).
    The payload format: <indicator>_<part>_<genre>_<start>
    """
    print(payload)
    _, part, genre, start = payload.split('_')
    start_index = int(start)
    addition=0
    # Depending on the part ("2" for jobs, otherwise training)
    if part == "2":
        action_result = db.get_emploi_by_genre(genre, start_index)
    elif part == "3":
        action_result = db.get_courses_by_genre(genre, start_index)
    elif part == "4":
        action_result = db.get_support_opportunities_by_type(genre, start_index)
    elif part == "5":
        action_result = db.get_financing_opportunities(genre, start_index)
    

    response_text = action_result["text"]
    response = {}

    # If no titles are returned, just send a text message with a main menu option
    if "titles" not in action_result:
        response["text"] = response_text
        response["quick_replies"] = [{
            "content_type": "text",
            "title": "ุงููุงุฆูุฉ ุงูุฑูููุณูุฉ",
            "payload": "1"
        }]
        return response

    # Build a button template if titles are available
    addition=len(action_result["titles"])
    buttons = []
    for index, title in enumerate(action_result["titles"]):
        url = "https://www.messenger.com"
        if "urls" in action_result:
            url = action_result["urls"][index]
        buttons.append({
            "type": "web_url",
            "url": url,
            "title": title
        })
    response = {
        "attachment": {
            "type": "template",
            "payload": {
                "template_type": "button",
                "text": response_text,
                "buttons": buttons
            }
        }
    }

    # Add pagination quick reply ("ุฒูุฏูู") and main menu
    next_payload = f"{_}_{part}_{genre}_{start_index+addition}"
    response["quick_replies"] = [
        {
            "content_type": "text",
            "title": "ุฒูุฏูู",
            "payload": next_payload
        },
        {
            "content_type": "text",
            "title": "ุงููุงุฆูุฉ ุงูุฑูููุณูุฉ",
            "payload": "1"
        }
    ]

    return response


def build_response(payload: str) -> dict:
    """
    Construct a response message based on the conversation node identified by 'payload'.
    """
    node = tree.get(payload)
    if not node:
        return {"text": "ุนุฐุฑุงูุ ูู ุฃููู ุฐูู."}

    response_text = node['message']
    response = {}
    start = 0
    # If the node has an action to execute, append its result
    if callable(node["action"]):
        action_result = node["action"]()
        start = len(action_result["titles"])
        response_text += "\n" + action_result["text"]

        # Construct button template if there are titles
        buttons = []
        if "titles" in   action_result :
            for index,title in enumerate(action_result["titles"]):
                url ="https://www.messenger.com"
                if "urls" in action_result:
                    url=action_result["urls"][index]
                buttons.append({
                    "type": "web_url",
                    "url":  url,
                    "title": title
                })

            response = {
                "attachment": {
                    "type": "template",
                    "payload": {
                        "template_type": "button",
                        "text": response_text,
                        "buttons": buttons
                    }
                }
            }
    else:
        response = {"text": response_text}

    # Add quick replies if the node defines options
    if 'options' in node:
        response["quick_replies"] = build_quick_replies(node['options'], payload,start)

    return response


@app.post("/webhook")
async def webhook(request: Request):
    """
    Handle incoming webhook events from Facebook.
    """
    data = await request.json()
    print("Received a message event" )

    if data.get('object') == 'page':
        for entry in data.get('entry', []):
            for event in entry.get('messaging', []):
                sender_id = event['sender']['id']
                show_typing(sender_id, True)

                # If user pressed a quick reply button
                if 'quick_reply' in event.get('message', {}):
                    print("Quick reply received")
                    payload = event['message']['quick_reply']['payload']

                    if payload in tree:
                        response_message = build_response(payload)
                        print("Sending message:", response_message)
                        send_message(sender_id, response_message)
                    elif moreOptionsPressedIndicator in payload:
                        # Handle pagination (load more options)
                        print(payload)
                        response_message = build_more_option_response(payload)
                        send_message(sender_id, response_message)
                    else:
                        send_message(sender_id, {"text": "ุนุฐุฑุงูุ ูู ุฃููู ุฐูู."})

                # If user sent a text message
                elif 'message' in event:
                    print("Text message received")
                    """user_text = event["message"]["text"]
                    intent = await get_intent(user_text)
                    print("Identified intent:", intent)

                    # Map the identified intent to a node payload
                    predicted_payload = intent_to_payload[intent]"""
                    response_message = build_response("1")
                    print("Sending message:", response_message)
                    send_message(sender_id, response_message)

                show_typing(sender_id, False)


def show_typing(user_id: str, is_typing: bool) -> dict:
    """
    Show or hide the typing indicator for the user.
    """
    url = f"https://graph.facebook.com/v11.0/{config.PAGE_ID}/messages?access_token={config.BOT_TOKEN}"
    headers = {"Content-Type": "application/json"}
    action = "typing_on" if is_typing else "typing_off"
    body = {
        "recipient": {"id": user_id},
        "sender_action": action
    }
    response = requests.post(url, json=body, headers=headers)
    return response.json()


if __name__ == "__main__":
    import os
    import sys
    import json

    if getattr(sys, 'frozen', False):
        # The executable is running in a frozen state
        # sys.executable is the full path to the main.exe file
        base_path = os.path.dirname(sys.executable)
    else:
        # Running in normal Python environment
        base_path = os.path.dirname(os.path.abspath(__file__))

    config_path = os.path.join(base_path, "config.json")

    with open(config_path, "r") as f:
        configurations = dict(json.load(f))
    config.dbconfig=configurations["db"]
    config.BOT_TOKEN=configurations["pageconfig"]["BOT_TOKEN"]
    config.PAGE_ID=configurations["pageconfig"]["PAGE_ID"]



    #if __name__ == "__main__":
    import uvicorn
    import os
    import sys

    # Determine if we are running in a PyInstaller bundle
    if getattr(sys, 'frozen', False):
        # Running in a bundle
        base_path = sys._MEIPASS
    else:
        # Running in normal Python environment
        base_path = os.path.dirname(os.path.abspath(__file__))

    ssl_key_path = os.path.join(base_path, "sslVerification", "fernabot.top.key")
    ssl_cert_path = os.path.join(base_path, "sslVerification", "fullchain.pem")

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        ssl_keyfile=ssl_key_path,
        ssl_certfile=ssl_cert_path
    )
